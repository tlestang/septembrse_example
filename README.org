#+TITLE: What's the deal with Python wheels?

This walkthrough covers a fundamental aspect of Python packaging, the
wheel distribution format. A wheel is a way to transport a Python
package, for instance to share it with others, making sure it remains
installable on a wide range of systems. In most situations, a Python
wheel is is downloaded when yu ~pip install~ a package that is not
present or cached on your system.

#+begin_example
$ pip install numpy
Collecting numpy
  Downloading numpy-1.21.2-cp39-cp39-manylinux_2_12_x86_64.manylinux2010_x86_64.whl (15.8 MB)
     |████████████████████████████████| 15.8 MB 65 kB/s 
Installing collected packages: numpy
Successfully installed numpy-1.21.2  
#+end_example

That file
~numpy-1.21.2-cp39-cp39-manylinux_2_12_x86_64.manylinux2010_x86_64.whl~
is a Python wheel. It contains everything needed to install NumPy 1.21
in your Python package directory. NumPy is a big package, a part of
its source being written in C with dependencies on lower-level linear
algebra libraries such as OpenBLAS. How is it downloading and
installing in a few seconds? Should you not make sure your have
OpenBLAS installed before?

Since 2012, The Python wheel is the standard recommended format for
distributing Python packages. It addresses many shortcomings of other
distribution formats like source distributions (~sdist~) or Python
eggs (~bdist_eggs~).

Starting from building and sharing /source/ distributions, this
walkthrough motivates the need for a /built/ distribution format. It
illustrates the build and installation of wheels based on a simple
example package and discuss the case of GNU/Linux distributions and
the manylinux tag. Finally, it introduces ~cibuildwheel~, a Python
utility running on Continuous Integration systems capable of
automating the build of wheels.

* Example package
  #+begin_src shell :results output
    find src
  #+end_src

  #+RESULTS:
  : src
  : src/cpp
  : src/cpp/ddot.cpp
  : src/example_pkg
  : src/example_pkg/__init__.py

  One function ~dot_product~ that returns the dot product of two
  lists. This function calls another function ~ddot~, implemented
  inside a C++ extension module. This C++ function itself depends on
  the ~cblas_ddot~, which is one of the level 1 BLAS functions. These
  are provided by external libraries such as GSL, OpenBLAS or MKL.

  This is an overly complicated way for implementing a dot product,
  but useful to illustrate the behavior and benefits of Python wheels.

  Alongside the source is a setup script, using ~scikit-build~ to
  interface with CMake.
  #+begin_src python
    """Setup example package
    """
    from setuptools import find_packages
    from skbuild import setup
    
    setup(
	name='septembrse',
	license='GPLv3',
	description='A simple example package for the walkthrough',
	author='Thibault Lestang',
	author_email='thibault.lestang@protonmail.com',
	packages=find_packages('src'),
	package_dir={'': 'src'},
	cmake_install_dir="src/example_pkg",
    )
  #+end_src
  
* Source distributions

  Pretend that we want to share this package with a friend.

  First option is to put everything in an archive:
  #+begin_src shell
	tar -cf septembrse-0.0.0.tar.gz \
	    pyproject.toml \
	    setup.py \
	    CMakeLists.txt \
	    pybind11 \
	    src
  #+end_src

  Better done autmatically using ~setuptools~:
  #+begin_src shell
    python setup.py sdist
  #+end_src

  This creates a ~source distribution~, that contains all the files
  necessary to build and install the package. It also embarks some
  metadata (~PKG-INFO~). Lots of formats available:

  #+begin_src shell :results output
    python setup.py sdist --help-formats
  #+end_src

  #+RESULTS:
  : List of available source distribution formats:
  :   --formats=bztar  bzip2'ed tar-file
  :   --formats=gztar  gzip'ed tar-file
  :   --formats=tar    uncompressed tar file
  :   --formats=xztar  xz'ed tar-file
  :   --formats=zip    ZIP file
  :   --formats=ztar   compressed tar file
  
  You can give an ~sdist~ to ~pip~

  #+begin_src shell
    pip install dist/septembrse-0.0.0.tar.gz
  #+end_src

  This runs the ~setup.py~ script. It
  1. Installs the build tools (~setuptools~, ~cmake~, ~scikit-build~)
  2. Writes metadata
  3. Compiles the extension module
  4. Bundles everything together and copies it to the right
     install location.
 
  Easy enough. We bundled our package's sources into a archive and now
  we can share it to our friends so they can install with ~pip~ in the
  same way. On the friends laptop, we try to install the package:

  #+begin_example
    $ docker run -it -v `pwd`/dist:/home/user/dist pyenv
    user@ee08067a19d3:~$ pip install dist/septembrse-0.0.0.tar.gz
    Processing ./dist/septembrse-0.0.0.tar.gz
      ERROR: Command errored out with exit status 1:
      ...
      Complete output (127 lines):
      ... 
      -- Could NOT find BLAS (missing: BLAS_LIBRARIES)
      -- Configuring done
      CMake Error: The following variables are used in this project, but they are set to NOTFOUND.
  #+end_example

  Our friend cannot install the package since they don't have a BLAS library
  installed!
  #+begin_src shell
    apt install libopenblas-dev
  #+end_src

  When installing a sdist, the ~setup.py~ script is run. This is a
  scurity issue:

  #+begin_src python
    # setup.py
    
    print("""
    
    
    My MALICIOUS CODE here
    
    
    
    """)
    
    setup( # ...
    )
  #+end_src

* Built distributions

  Alternative to source distributions. Setup script is run once to
  create the distribution. Installing from the built distribution
  doesn't require to run to run it, files are just extracted and
  copied to the right location. If the package contains extension
  module, these are compiled once when building the distribution.
  In this case the distribution is a /binary distribution/.

  Since 2012 the standard for built distributions is Python wheels.
  It adresses many of the shortcomings of Python eggs, which was the
  previous widely used (but not standard) built distribution format.

  A wheel is built using ~setuptools~ with the ~wheel~ package.

  #+begin_src shell
    python setup.py bdist_wheel
  #+end_src

  In contrast to making a sdist, this performs a "fake" install of the
  the package and bundles the result inside an archive. Part of this
  install process is compiling the extension modules.

  Binary wheels are platform and python-version specific.  You need to
  build a wheel for each platform, for each python version you want to
  support. This can be tedious and error prone, but we'll see how to
  automate that (~cibuildwheel~).

  A pure python wheel is a wheel with no binary code in it. This has
  a special tag ~none~. Can be used everywhere.

  Benefits of using wheels include:
  - Smaller files
  - Faster installation (just copying files around)
  - No execution of arbitrary Python code
  - Users don't have to have to build time requirements
  - Descriptive names (platform, python version)

* manylinux

  On GNU/Linux, virtually every executable or shared library will have
  a dynamic dependency on the GNU standard c library (/glibc/). This
  library is responsible for interfacing with the Linux kernel.

  This is a problem because not all GNU/Linux distros come with the
  same version of /glibc/. This is true between older and recent
  versions of the same distributions, but also possible between
  distributions of the same generation. Programs linked against newer
  version of glibc will not work on a different system with an older
  version.

  Fortunately glibc developers ensure that the opposite is true: a
  program linked against an older version is guaranteed to work with a
  newer version. This is known as backward compatibility. This means
  that by building our wheels on older GNU/Linux systems we can make
  sure they will be usable on a large set of GNU/Linux distros out
  there: on /manylinux/ distributions.

  We don't have to it ourselves. They're is a group of people named
  the [[https://www.pypa.io/en/latest/][Python Packaging Authority]] that take care of maintaining
  projects used in Python packaging (e.g. PyPI). They maintain [[https://github.com/pypa/manylinux#docker-images][a set
  of Docker images]] you can use to buiold your wheels in.

  For instance a Debian 9 (stretch) image that contains glibc 2.24:
  
  #+begin_src shell
    docker run -i -t -v `pwd`:/io quay.io/pypa/manylinux_2_24_x86_64 /bin/bash
  #+end_src

  Manylinux images contain all currently supported Python versions:
  #+begin_src shell
    root@221b30d4d160:/# ls /opt/python
    cp310-cp310  cp36-cp36m  cp37-cp37m  cp38-cp38	cp39-cp39  pp37-pypy37_pp73
  #+end_src

  Let's build our wheel. First we install OpenBLAS (required to build
  the C++ extension module).
  #+begin_src shell
    apt update && apt install libopenblas-dev
  #+end_src

  We then build the wheel
  #+begin_src shell
    root@221b30d4d160:/# cd /io/
    root@221b30d4d160:/io# /opt/python/cp38-cp38/bin/pip wheel .
  #+end_src

  #+begin_src shell
    root@221b30d4d160:/io# ls -l | grep .whl$
    -rw-r--r-- 1 root root   42127 Sep  3 09:58 septembrse-0.0.0-cp38-cp38-linux_x86_64.whl
  #+end_src

  Are we good yet? Not exactly. A valid manylinux wheel should have a
  name tag with ~manylinux~ not ~linux~. The attribution of this name
  tag is not the job of ~pip~, but it is ~auditwheel~'s.

  The utility ~auditwheel~ scans the wheel and decides whether or not
  it can be attributed a ~manylinux~ tag. If yes, it creates a new
  wheel with the correct name tag.

  Let's first inspect out wheel - this only prints info, doest not
  create a new wheel yet.

  #+begin_src shell
    root@221b30d4d160:/io# auditwheel show septembrse-0.0.0-cp38-cp38-linux_x86_64.whl
    
    septembrse-0.0.0-cp38-cp38-linux_x86_64.whl is consistent with the
    following platform tag: "linux_x86_64".
    
    The wheel references external versioned symbols in these
    system-provided shared libraries: libc.so.6 with versions
    {'GLIBC_2.14', 'GLIBC_2.2.5', 'GLIBC_2.4', 'GLIBC_2.3.2', 'GLIBC_2.6',
    'GLIBC_2.17', 'GLIBC_2.3.4', 'GLIBC_2.7', 'GLIBC_2.10', 'GLIBC_2.3'},
    libgcc_s.so.1 with versions {'GCC_3.3', 'GCC_4.3.0', 'GCC_3.0',
    'GCC_4.2.0', 'GCC_3.3.1'}, libstdc++.so.6 with versions
    {'CXXABI_1.3.2', 'CXXABI_1.3.5', 'CXXABI_1.3.8', 'GLIBCXX_3.4.18',
    'CXXABI_1.3.3', 'GLIBCXX_3.4', 'CXXABI_1.3', 'CXXABI_1.3.9',
    'GLIBCXX_3.4.21', 'GLIBCXX_3.4.20'}, libm.so.6 with versions
    {'GLIBC_2.23', 'GLIBC_2.2.5'}, libgfortran.so.3 with versions
    {'GFORTRAN_1.0'}, libpthread.so.0 with versions {'GLIBC_2.2.5',
    'GLIBC_2.3.2'}, libquadmath.so.0 with versions {'QUADMATH_1.0'}
    
    This constrains the platform tag to "manylinux_2_24_x86_64". In order
    to achieve a more compatible tag, you would need to recompile a new
    wheel from source on a system with earlier versions of these
    libraries, such as a recent manylinux image.
  #+end_src

  Inside the wheel there is binary code (compiled extension module)
  that references symbols in various shared libraries. These symbols
  (function names) they also specifiy the version of the library they
  correspond to. If you want to learn more about this, yo can look at
  the symbol versioning of glibc - that's how glibc devs ensure
  backward compatibility.

  Anyway - the important point is: every GLIBC is below 2.24 and
  that's what we have installed in that docker image.  Because we just
  build the wheel on a system with glibc 2.24 the wheel will work on
  any GNU/Linux system with a version of glibc below or equal to 2.24.

  Let's produce the manylinux wheel with ~auditwheel repair~:
  #+begin_src shell
    auditwheel repair septembrse-0.0.0-cp38-cp38-linux_x86_64.whl
  #+end_src

  A new direcoty ~wheelhouse~ was created with out manylinux wheel in it.

** Runtime dependency on OpenBLAS

   There's is one detail I glossed over.

   Our C extension module has dynamics dependencies to various shared
   libraries.

   #+begin_src shell
     root@221b30d4d160:/io# ldd example_pkg/example.cpython-38-x86_64-linux-gnu.so 
	     linux-vdso.so.1 (0x00007ffd2dfed000)
	     libopenblas.so.0 => /usr/lib/libopenblas.so.0 (0x00007ff591260000)
	     libstdc++.so.6 => /usr/lib/x86_64-linux-gnu/libstdc++.so.6 (0x00007ff590ede000)
	     libm.so.6 => /lib/x86_64-linux-gnu/libm.so.6 (0x00007ff590bda000)
	     libgcc_s.so.1 => /lib/x86_64-linux-gnu/libgcc_s.so.1 (0x00007ff5909c3000)
	     libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007ff590624000)
	     libpthread.so.0 => /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007ff590407000)
	     libgfortran.so.3 => /usr/lib/x86_64-linux-gnu/libgfortran.so.3 (0x00007ff5900e1000)
	     /lib64/ld-linux-x86-64.so.2 (0x00007ff5935d1000)
	     libquadmath.so.0 => /usr/lib/x86_64-linux-gnu/libquadmath.so.0 (0x00007ff58fea2000)
   #+end_src

   Most of them are libraries you'd find on many GNU/Linux systems and
   therefore no problem.  Our extension module was linked against the
   OpenBLAS shared library that is not pre-installed. Further
   different linux distributions package differnt versions and that's
   going to make the wheel unusable on another system.

   Python wheels can embed external shared libraries such a
   libopenblas.  This makes the wheel self-contained and thereofre
   portable.  The bundling of external shared libraries is performed
   by ~auditwheel repair~.
