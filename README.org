#+TITLE: What's the deal with Python wheels?

This walkthrough covers a fundamental aspect of Python packaging, the
wheel distribution format.

A wheel is a way of distributing a Python package.

#+begin_example
$ pip install numpy
Collecting numpy
  Downloading numpy-1.21.2-cp39-cp39-manylinux_2_12_x86_64.manylinux2010_x86_64.whl (15.8 MB)
     |████████████████████████████████| 15.8 MB 65 kB/s 
Installing collected packages: numpy
Successfully installed numpy-1.21.2  
#+end_example

That file
~numpy-1.21.2-cp39-cp39-manylinux_2_12_x86_64.manylinux2010_x86_64.whl~
is a Python wheel. It contains everything needed to install NumPy 1.21
in your Python package directory. A wheel plays the role of what we
call a package in some other contexts (e.g. ~.rpm~ or ~.deb~ package
installation on GNU/Linux) but in Python parlance the word package is
already taken. In Python we talk of distribution (packages) to avoid
confusion. A wheel is a distribution - it /contains/ a Python package.

There are mainly three sections to this walktrough:
1. Building a wheel for an example package
2. The ~manylinux~ policy(ies) and how to build portable wheels.
3. Automatically building and releasing wheels on Continuous
   Integration systems.
   
* Example package

  The example package consists of two files:
  - A C++ extension module ~src/cpp/ddot.cpp~ named ~example~.
  - A Python file ~dot_product.py~ that imports the ~example~ extension module.

  Additionanly, the C++ extension module relies on the ~cblas_ddot~
  which comes from an external C library (a BLAS library such as
  OpenBLAS).

  Package build and installation:
  - The extension module is written using ~pybind11~ which a C++
    library that makes it easy interface Python and C++.
  - I used CMake to manage the build simply because CMake works well
    with pybind11.  
  - Overall, the Python package is built with ~scikit-build~ which is
    a extension of ~setuptools~ that makes it easy to use CMake as
    part of the setup process.

* Building a wheel distribution

  Alternative to source distributions. Setup script is run once to
  create the distribution. Installing from the built distribution
  doesn't require to run to run it, files are just extracted and
  copied to the right location. If the package contains extension
  module, these are compiled once when building the distribution.
  In this case the distribution is a /binary distribution/.

  Since 2012 the standard for built distributions is Python wheels.
  It adresses many of the shortcomings of Python eggs, which was the
  previous widely used (but not standard) built distribution format.

  A wheel is built using ~setuptools~ with the ~wheel~ package.

  #+begin_src shell
    python setup.py bdist_wheel
  #+end_src

  In contrast to making a sdist, this performs a "fake" install of the
  the package and bundles the result inside an archive. Part of this
  install process is compiling the extension modules.

  Binary wheels are platform and python-version specific.  You need to
  build a wheel for each platform, for each python version you want to
  support. This can be tedious and error prone, but we'll see how to
  automate that (~cibuildwheel~).

  A pure python wheel is a wheel with no binary code in it. This has
  a special tag ~none~. Can be used everywhere.

  Benefits of using wheels include:
  - Smaller files
  - Faster installation (just copying files around)
  - No execution of arbitrary Python code
  - Users don't have to have to build time requirements
  - Descriptive names (platform, python version)

* manylinux

  On GNU/Linux, virtually every executable or shared library will have
  a dynamic dependency on the GNU standard c library (/glibc/). This
  library is responsible for interfacing with the Linux kernel.

  This is a problem because not all GNU/Linux distros come with the
  same version of /glibc/. This is true between older and recent
  versions of the same distributions, but also possible between
  distributions of the same generation. Programs linked against newer
  version of glibc will not work on a different system with an older
  version.

  Fortunately glibc developers ensure that the opposite is true: a
  program linked against an older version is guaranteed to work with a
  newer version. This is known as backward compatibility. This means
  that by building our wheels on older GNU/Linux systems we can make
  sure they will be usable on a large set of GNU/Linux distros out
  there: on /manylinux/ distributions.

  We don't have to it ourselves. They're is a group of people named
  the [[https://www.pypa.io/en/latest/][Python Packaging Authority]] that take care of maintaining
  projects used in Python packaging (e.g. PyPI). They maintain [[https://github.com/pypa/manylinux#docker-images][a set
  of Docker images]] you can use to buiold your wheels in.

  For instance a Debian 9 (stretch) image that contains glibc 2.24:
  
  #+begin_src shell
    docker run -i -t -v `pwd`:/io quay.io/pypa/manylinux_2_24_x86_64 /bin/bash
  #+end_src

  Manylinux images contain all currently supported Python versions:
  #+begin_src shell
    root@221b30d4d160:/# ls /opt/python
    cp310-cp310  cp36-cp36m  cp37-cp37m  cp38-cp38	cp39-cp39  pp37-pypy37_pp73
  #+end_src

  Let's build our wheel. First we install OpenBLAS (required to build
  the C++ extension module).
  #+begin_src shell
    apt update && apt install libopenblas-dev
  #+end_src

  We then build the wheel
  #+begin_src shell
    root@221b30d4d160:/# cd /io/
    root@221b30d4d160:/io# /opt/python/cp38-cp38/bin/pip wheel .
  #+end_src

  #+begin_src shell
    root@221b30d4d160:/io# ls -l | grep .whl$
    -rw-r--r-- 1 root root   42127 Sep  3 09:58 septembrse-0.0.0-cp38-cp38-linux_x86_64.whl
  #+end_src

  Are we good yet? Not exactly. A valid manylinux wheel should have a
  name tag with ~manylinux~ not ~linux~. The attribution of this name
  tag is not the job of ~pip~, but it is ~auditwheel~'s.

  The utility ~auditwheel~ scans the wheel and decides whether or not
  it can be attributed a ~manylinux~ tag. If yes, it creates a new
  wheel with the correct name tag.

  Let's first inspect out wheel - this only prints info, doest not
  create a new wheel yet.

  #+begin_src shell
    root@221b30d4d160:/io# auditwheel show septembrse-0.0.0-cp38-cp38-linux_x86_64.whl
    
    septembrse-0.0.0-cp38-cp38-linux_x86_64.whl is consistent with the
    following platform tag: "linux_x86_64".
    
    The wheel references external versioned symbols in these
    system-provided shared libraries: libc.so.6 with versions
    {'GLIBC_2.14', 'GLIBC_2.2.5', 'GLIBC_2.4', 'GLIBC_2.3.2', 'GLIBC_2.6',
    'GLIBC_2.17', 'GLIBC_2.3.4', 'GLIBC_2.7', 'GLIBC_2.10', 'GLIBC_2.3'},
    libgcc_s.so.1 with versions {'GCC_3.3', 'GCC_4.3.0', 'GCC_3.0',
    'GCC_4.2.0', 'GCC_3.3.1'}, libstdc++.so.6 with versions
    {'CXXABI_1.3.2', 'CXXABI_1.3.5', 'CXXABI_1.3.8', 'GLIBCXX_3.4.18',
    'CXXABI_1.3.3', 'GLIBCXX_3.4', 'CXXABI_1.3', 'CXXABI_1.3.9',
    'GLIBCXX_3.4.21', 'GLIBCXX_3.4.20'}, libm.so.6 with versions
    {'GLIBC_2.23', 'GLIBC_2.2.5'}, libgfortran.so.3 with versions
    {'GFORTRAN_1.0'}, libpthread.so.0 with versions {'GLIBC_2.2.5',
    'GLIBC_2.3.2'}, libquadmath.so.0 with versions {'QUADMATH_1.0'}
    
    This constrains the platform tag to "manylinux_2_24_x86_64". In order
    to achieve a more compatible tag, you would need to recompile a new
    wheel from source on a system with earlier versions of these
    libraries, such as a recent manylinux image.
  #+end_src

  Inside the wheel there is binary code (compiled extension module)
  that references symbols in various shared libraries. These symbols
  (function names) they also specifiy the version of the library they
  correspond to. If you want to learn more about this, yo can look at
  the symbol versioning of glibc - that's how glibc devs ensure
  backward compatibility.

  Anyway - the important point is: every GLIBC is below 2.24 and
  that's what we have installed in that docker image.  Because we just
  build the wheel on a system with glibc 2.24 the wheel will work on
  any GNU/Linux system with a version of glibc below or equal to 2.24.

  Let's produce the manylinux wheel with ~auditwheel repair~:
  #+begin_src shell
    auditwheel repair septembrse-0.0.0-cp38-cp38-linux_x86_64.whl
  #+end_src

  A new direcoty ~wheelhouse~ was created with out manylinux wheel in it.

** Runtime dependency on OpenBLAS

   There's is one detail I glossed over.

   Our C extension module has dynamics dependencies to various shared
   libraries.

   #+begin_src shell
     root@221b30d4d160:/io# ldd example_pkg/example.cpython-38-x86_64-linux-gnu.so 
	     linux-vdso.so.1 (0x00007ffd2dfed000)
	     libopenblas.so.0 => /usr/lib/libopenblas.so.0 (0x00007ff591260000)
	     libstdc++.so.6 => /usr/lib/x86_64-linux-gnu/libstdc++.so.6 (0x00007ff590ede000)
	     libm.so.6 => /lib/x86_64-linux-gnu/libm.so.6 (0x00007ff590bda000)
	     libgcc_s.so.1 => /lib/x86_64-linux-gnu/libgcc_s.so.1 (0x00007ff5909c3000)
	     libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007ff590624000)
	     libpthread.so.0 => /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007ff590407000)
	     libgfortran.so.3 => /usr/lib/x86_64-linux-gnu/libgfortran.so.3 (0x00007ff5900e1000)
	     /lib64/ld-linux-x86-64.so.2 (0x00007ff5935d1000)
	     libquadmath.so.0 => /usr/lib/x86_64-linux-gnu/libquadmath.so.0 (0x00007ff58fea2000)
   #+end_src

   Most of them are libraries you'd find on many GNU/Linux systems and
   therefore no problem.  Our extension module was linked against the
   OpenBLAS shared library that is not pre-installed. Further
   different linux distributions package differnt versions and that's
   going to make the wheel unusable on another system.

   Python wheels can embed external shared libraries such a
   libopenblas.  This makes the wheel self-contained and thereofre
   portable.  The bundling of external shared libraries is performed
   by ~auditwheel repair~.
